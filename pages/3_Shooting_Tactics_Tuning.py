# -*- coding: utf-8 -*-
"""Streamlit Data Visualization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1c14jklZWYWt45ahF1_CYVBYbhKPPoGbb

# Interactive Soccer Goal Prediction
"""

# from google.colab import drive
# import os
# drive.mount('/content/drive')
# os.chdir('/content/drive/MyDrive/243 Project') # customize this line to your working directory

# Commented out IPython magic to ensure Python compatibility.
import ipywidgets as widgets
from ipywidgets import HBox, VBox
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from IPython.display import display
import joblib
# %matplotlib inline

import torch
from torch.utils.data import Dataset, DataLoader
import torch.nn as nn
import torch.nn.functional as F
import torch.optim as optim

from sklearn.base import BaseEstimator, ClassifierMixin
import torch
import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
import altair as alt
import seaborn as sns
import numpy as np
import matplotlib.pyplot as plt
import pydeck as pdk

import sys
import os
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
PARENT_DIR = os.path.dirname(SCRIPT_DIR)
sys.path.append(os.path.dirname(PARENT_DIR))
from footer import footer
footer()

class PyTorchClassifier(BaseEstimator, ClassifierMixin):
    def __init__(self, model):
        self.model = model

    def fit(self, X, y):
        # Since the model is already trained, we just return self.
        # If you later decide you want to allow retraining or further training,
        # you can implement that logic here.
        return self

    def predict_proba(self, X):
        # Ensure the model is in evaluation mode
        self.model.eval()

        # Convert X to a torch tensor
        X_numpy = X.values if isinstance(X, pd.DataFrame) else X
        X_tensor = torch.tensor(X_numpy, dtype=torch.float32)

        with torch.no_grad():
            # Get model outputs
            outputs = self.model(X_tensor)
            # Apply softmax to get probabilities
            probabilities = torch.nn.functional.softmax(outputs, dim=1)

        # Return probabilities as a NumPy array
        return probabilities.numpy()

    def predict(self, X):
        # Get probabilities
        proba = self.predict_proba(X)
        # Convert probabilities to predictions
        return torch.argmax(torch.tensor(proba), dim=1).numpy()

# Define the two hidden layer neural network
class TwoHiddenLayerDropout(nn.Module):
    def __init__(self, input_dim, hidden_dim1, hidden_dim2, dropout_rate=0.2):
        super(TwoHiddenLayerDropout, self).__init__()
        self.linear1 = nn.Linear(input_dim, hidden_dim1)
        self.dropout1 = nn.Dropout(dropout_rate)  # Dropout layer after the first linear transformation
        self.linear2 = nn.Linear(hidden_dim1, hidden_dim2)
        self.dropout2 = nn.Dropout(dropout_rate)  # Dropout layer after the second linear transformation
        self.linear3 = nn.Linear(hidden_dim2, 2)  # Assuming binary classification

    def forward(self, x):
        x = self.linear1(x)
        x = F.sigmoid(x)
        x = self.dropout1(x)  # Apply dropout after the first activation
        x = self.linear2(x)
        x = F.sigmoid(x)
        x = self.dropout2(x)  # Apply dropout after the second activation
        x = self.linear3(x)
        return x


st.write('# Shooting Tactics Tuning')

vc = joblib.load('vc.pkl')

# Initialize session state for storing attempts and latest prediction
if 'data' not in st.session_state:
    st.session_state['data'] = pd.DataFrame(columns=['Attempt', 'Probability', 'Input Details'])
if 'latest_prediction' not in st.session_state:
    st.session_state['latest_prediction'] = 0

# Function to clear the plot data
def clear_data():
    st.session_state['data'] = pd.DataFrame(columns=['Attempt', 'Probability', 'Input Details'])

# Function to add a data point to the plot
def add_data_point():
    predicted_probability = st.session_state['latest_prediction']
    input_details = (f"Period: {period},<br>Minute: {minute},<br>Play Pattern: {play_pattern},<br>"
                     f"Position: {position},<br>Duration: {duration},<br>Shot Technique: {shot_technique},<br>"
                     f"Shot Body Part: {shot_body_part},<br>Bodypart Angle: {bodypart_angle},<br>"
                     f"Shot Type: {shot_type},<br>Under Pressure: {under_pressure},<br>"
                     f"Shot First Time: {shot_first_time},<br>Shot One on One: {shot_one_on_one},<br>"
                     f"Shot Aerial Won: {shot_aerial_won},<br>Shot Open Goal: {shot_open_goal},<br>"
                     f"Shot Redirect: {shot_redirect},<br>Off Camera: {off_camera},<br>"
                     f"Shot After Dribble: {shot_after_dribble},<br>Shot With Pass: {shot_with_pass},<br>"
                     f"Inside 18: {inside_18},<br>Assist: {assist},<br>Assist Play Pattern: {assist_play_pattern},<br>"
                     f"Shot Distance: {shot_distance},<br>Shot Angle: {shot_angle}")
    new_attempt = len(st.session_state['data']) + 1
    st.session_state['data'] = pd.concat([st.session_state['data'], pd.DataFrame({'Attempt': [new_attempt], 'Probability': [predicted_probability], 'Input Details': [input_details]})], ignore_index=True)

# Function to predict based on current inputs and update the metrics display
def update_prediction():
    columns = ['under_pressure', 'shot_first_time', 'shot_one_on_one',
                'shot_aerial_won', 'shot_open_goal', 'out', 'shot_redirect',
                'off_camera', 'shot_follows_dribble', 'shot_with_pass', 'inside_18',
                'play_pattern_From Corner', 'play_pattern_From Counter',
                'play_pattern_From Free Kick', 'play_pattern_From Goal Kick',
                'play_pattern_From Keeper', 'play_pattern_From Kick Off',
                'play_pattern_From Throw In', 'play_pattern_Other',
                'play_pattern_Regular Play', 'position_Center Attacking Midfield',
                'position_Center Back', 'position_Center Defensive Midfield',
                'position_Center Forward', 'position_Goalkeeper',
                'position_Left Attacking Midfield', 'position_Left Back',
                'position_Left Center Back', 'position_Left Center Forward',
                'position_Left Center Midfield', 'position_Left Defensive Midfield',
                'position_Left Midfield', 'position_Left Wing',
                'position_Left Wing Back', 'position_Right Attacking Midfield',
                'position_Right Back', 'position_Right Center Back',
                'position_Right Center Forward', 'position_Right Center Midfield',
                'position_Right Defensive Midfield', 'position_Right Midfield',
                'position_Right Wing', 'position_Right Wing Back',
                'shot_technique_Backheel', 'shot_technique_Diving Header',
                'shot_technique_Half Volley', 'shot_technique_Lob',
                'shot_technique_Normal', 'shot_technique_Overhead Kick',
                'shot_technique_Volley', 'shot_body_part_Head',
                'shot_body_part_Left Foot', 'shot_body_part_Other',
                'shot_body_part_Right Foot', 'shot_type_Corner', 'shot_type_Free Kick',
                'shot_type_Open Play', 'shot_type_Penalty', 'assist_Ground Pass',
                'assist_High Pass', 'assist_Low Pass', 'assist_nan',
                'assist_play_pattern_From Corner', 'assist_play_pattern_From Counter',
                'assist_play_pattern_From Free Kick',
                'assist_play_pattern_From Goal Kick', 'assist_play_pattern_From Keeper',
                'assist_play_pattern_From Kick Off',
                'assist_play_pattern_From Throw In', 'assist_play_pattern_Other',
                'assist_play_pattern_Regular Play', 'assist_play_pattern_nan',
                'bodypart_angle_Left - Head', 'bodypart_angle_Left - Inside Foot',
                'bodypart_angle_Left - Outside Foot', 'bodypart_angle_Other',
                'bodypart_angle_Right - Head', 'bodypart_angle_Right - Inside Foot',
                'bodypart_angle_Right - Outside Foot', 'period', 'minute', 'duration',
                'shot_distance', 'shot_angle']

    # Initialize the DataFrame with zeros
    df = pd.DataFrame(columns=columns)
    df = pd.concat([df, pd.DataFrame({col: 0 for col in columns}, index=[0])], ignore_index=True)


    # 1. numerical
    # Set the values for numerical features (make sure to replace with actual normalization values)
    df.loc[0, 'minute'] = (minute - 49.14) / 26.53
    df.loc[0, 'duration'] = (duration - 0.71) / 0.54
    df.loc[0, 'shot_distance'] = (shot_distance - 19.072) / 8.29
    df.loc[0, 'shot_angle'] = (shot_angle - 89.28) / 33.14
    if period == 'First Half':
        df.loc[0, 'period'] = (1 - 1.55) / 0.498
    else:
        df.loc[0, 'period'] = (2 - 1.55) / 0.498
    # player's locations do not need standardization
    # x['player_x'] = player_x
    # x['player_y'] = player_y


    # 2. boolean
    boolean_features = {'under_pressure': under_pressure,
                        'shot_first_time': shot_first_time,
                        'shot_one_on_one': shot_one_on_one,
                        'shot_aerial_won': shot_aerial_won,
                        'shot_open_goal': shot_open_goal,
                        'out': False,
                        'shot_redirect': shot_redirect,
                        'off_camera': off_camera,
                        'shot_follows_dribble': shot_after_dribble,
                        'shot_with_pass': shot_with_pass,
                        'inside_18': inside_18}
    # Set the values for boolean features
    for boolean_feature, value in boolean_features.items():
        if boolean_feature in df.columns:  # Check if the feature name is a valid column
            df.loc[0, boolean_feature] = int(value)


    # 3. categorical
    categorical_features = {
        'play_pattern': play_pattern,
        'position': position,
        'shot_technique': shot_technique,
        'shot_body_part': shot_body_part,
        'shot_type': shot_type,
        'assist': assist,
        'assist_play_pattern': assist_play_pattern,
        'bodypart_angle': bodypart_angle
    }

    # Set the values for categorical features
    for k, v in categorical_features.items():
        feature_name = k + '_' + v if v != 'NAN' else k
        if feature_name in df.columns:  # Check if the feature name is a valid column
            df.loc[0, feature_name] = 1

    # Make sure to convert any remaining object-type columns to categorical if needed
    for col in df.select_dtypes(include=['object']).columns:
        df[col] = df[col].astype('category')

    # Now predict with the voting classifier
    probs = vc.predict_proba(df)
    predicted_probability = probs[0][1]
    st.session_state['latest_prediction'] = predicted_probability
    # Update metrics display
    metrics_display.metric(label="Probability of Goal", value=f"{predicted_probability * 100:.2f}%")

# UI layout
# Using columns to organize the layout
col1, col2, col3 = st.columns(3)

with col1:
    period = st.selectbox('Period', ['First Half', 'Second Half'], index=0, key='period')
    minute = st.slider('Minute', min_value=0.0, max_value=100.0, value=10.0, step=0.1, key='minute')
    duration = st.slider('Duration', min_value=0.0, max_value=10.0, value=1.0, step=0.01, key='duration')
    shot_distance = st.slider('Shot Distance', min_value=0.0, max_value=100.0, value=1.0, step=0.01, key='shot_distance')

with col2:
    shot_angle = st.slider('Shot Angle', min_value=-0.29, max_value=180.0, value=90.0, step=0.01, key='shot_angle')
    play_pattern = st.selectbox('Play Pattern', ['From Corner', 'From Counter', 'From Free Kick', 'From Goal Kick',
                                                 'From Keeper', 'From Kick Off', 'From Throw In', 'Other', 'Regular Play'], index=8, key='play_pattern')
    position = st.selectbox('Position', ['Center Attacking Midfield', 'Center Back', 'Center Defensive Midfield',
                                         'Center Forward', 'Goalkeeper', 'Left Attacking Midfield', 'Left Back',
                                         'Left Center Back', 'Left Center Forward', 'Left Center Midfield',
                                         'Left Defensive Midfield', 'Left Midfield', 'Left Wing', 'Left Wing Back',
                                         'Right Attacking Midfield', 'Right Back', 'Right Center Back',
                                         'Right Center Forward', 'Right Center Midfield', 'Right Defensive Midfield',
                                         'Right Midfield', 'Right Wing', 'Right Wing Back'], index=3, key='position')

with col3:
    shot_technique = st.selectbox('Shot Technique', ['Backheel', 'Diving Header', 'Half Volley', 'Lob', 'Normal',
                                                     'Overhead Kick', 'Volley'], index=4, key='shot_technique')
    shot_body_part = st.selectbox('Shot Body Part', ['Head', 'Left Foot', 'Other', 'Right Foot'], index=3, key='shot_body_part')
    shot_type = st.selectbox('Shot Type', ['Corner', 'Free Kick', 'Open Play', 'Penalty'], index=2, key='shot_type')
    assist = st.selectbox('Assist', ['Ground Pass', 'High Pass', 'Low Pass', 'NAN'], index=0, key='assist')

# More inputs
assist_play_pattern = st.selectbox('Assist Play Pattern', ['From Corner', 'From Counter', 'From Free Kick', 'From Goal Kick',
                                                           'From Keeper', 'From Kick Off', 'From Throw In', 'Other', 'Regular Play', 'NAN'], index=8, key='assist_play_pattern')
bodypart_angle = st.selectbox('Bodypart Angle', ['Left - Head', 'Left - Inside Foot', 'Left - Outside Foot', 'Other',
                                                 'Right - Head', 'Right - Inside Foot', 'Right - Outside Foot'], index=0, key='bodypart_angle')

under_pressure = st.checkbox('Under Pressure', value=False, key='under_pressure')
shot_first_time = st.checkbox('Shot First Time', value=False, key='shot_first_time')
shot_one_on_one = st.checkbox('Shot One On One', value=False, key='shot_one_on_one')
shot_aerial_won = st.checkbox('Shot Aerial Won', value=False, key='shot_aerial_won')
shot_open_goal = st.checkbox('Shot Open Goal', value=False, key='shot_open_goal')
shot_redirect = st.checkbox('Shot Redirect', value=False, key='shot_redirect')
off_camera = st.checkbox('Off Camera', value=False, key='off_camera')
shot_after_dribble = st.checkbox('Shot After Dribble', value=False, key='shot_after_dribble')
shot_with_pass = st.checkbox('Shot With Pass', value=False, key='shot_with_pass')
inside_18 = st.checkbox('Inside 18', value=True, key='inside_18')

# Placeholder for the metrics display, updated in real-time
metrics_display = st.empty()

# Place a button to add a data point to the plot
st.button("Add Data Point", on_click=add_data_point)

# Button to clear the plot
st.button("Clear Plot", on_click=clear_data)

# Call update_prediction whenever the input changes to update metrics display in real-time
update_prediction()

# Plotting
fig = go.Figure()
if not st.session_state['data'].empty:
    fig.add_trace(go.Scatter(x=st.session_state['data']['Attempt'], y=st.session_state['data']['Probability'],
                             mode='markers+lines', name='Probability',
                             marker=dict(color=st.session_state['data']['Probability'].apply(lambda x: 'green' if x > 0.5 else 'red'), size=10),
                             text=st.session_state['data']['Input Details'], hoverinfo='text'))
    fig.add_hline(y=0.5, line_dash="dash", annotation_text="Threshold (0.5)", annotation_position="bottom right")
    fig.update_layout(title='Prediction Attempts Over Time', xaxis_title='Attempt', yaxis_title='Predicted Probability',
                      yaxis=dict(range=[0, 1]), hovermode='closest')
    st.plotly_chart(fig, use_container_width=True)